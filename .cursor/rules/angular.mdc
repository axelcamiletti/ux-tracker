---
description: 
globs: 
alwaysApply: true
---
# Angular Development Rules

## File Structure
- Each feature should be self-contained in its own directory with the following structure:
  ```
  feature-name/
  ├── components/
  │   └── component-name/
  │       ├── component-name.component.ts
  │       ├── component-name.component.html
  │       ├── component-name.component.css
  │       └── component-name.component.spec.ts
  ├── services/
  │   └── feature-name.service.ts
  ├── models/
  │   └── feature-name.model.ts
  └── interfaces/
      └── feature-name.interface.ts
  ```

- Global shared items should be in their respective directories:
  ```
  app/
  ├── shared/
  │   ├── components/    # Standalone shared components
  │   ├── directives/
  │   ├── pipes/
  │   └── utils/
  ├── core/
  │   ├── services/      # App-wide services
  │   ├── guards/
  │   └── interceptors/
  └── features/          # Each feature is standalone
      ├── home/
      ├── projects/
      └── study/
  ```

## Standalone Components
- Use standalone components exclusively
- Import dependencies directly in each component
- Group related components by feature/domain
- Share components through direct imports
- Use route-level code splitting for lazy loading

## Component Guidelines
- Always separate template, styles and logic:
  - Use external HTML files (`.component.html`)
  - Use external CSS files (`.component.css`)
  - Never use inline templates

## Naming Conventions
- Files: `kebab-case`
  - Components: `feature-name.component.ts`
  - Services: `feature-name.service.ts`
  - Models: `feature-name.model.ts`
  - Interfaces: `feature-name.interface.ts`
- Classes: `PascalCase`
  - Components: `FeatureNameComponent`
  - Services: `FeatureNameService`
  - Models: `FeatureNameModel`
- Methods and properties: `camelCase`
- Component selectors: `app-feature-name`
- Directive selectors: `appDirectiveName`
- Interface names: `IFeatureName`
- Enum names: `FeatureNameEnum`

## Component Structure
- Import order in component files:
  1. Angular core imports
  2. Angular material imports
  3. Third-party imports
  4. Application imports (ordered by relative path depth)
- Declare component members in the following order:
  1. Input/Output decorators
  2. ViewChild/ViewChildren
  3. Public properties
  4. Private properties
  5. Constructor
  6. Lifecycle hooks
  7. Public methods
  8. Private methods

## Template Guidelines
- Use `trackBy` with `*ngFor` for better performance
- Prefer `*ngIf` over `[hidden]`
- Use async pipe (`|`) for observables
- Keep templates clean and readable
- Extract complex logic to component methods
- Use meaningful names for template variables
- Keep templates focused on presentation logic
- Move complex business logic to services

## Style Guidelines
- Use Tailwind classes for styling
- Avoid inline styles
- Use CSS variables for theming
- Keep styles scoped to components
- Follow mobile-first approach
- Use BEM methodology for custom CSS classes when needed

## Best Practices
- Use TypeScript strict mode
- Implement proper error handling
- Use strong typing (avoid `any`)
- Follow Single Responsibility Principle
- Keep components small and focused
- Use services for data management and business logic
- Implement proper unsubscribe patterns for observables
- Use Angular's change detection strategies appropriately

## Performance
- Use `OnPush` change detection when possible
- Lazy load routes and features
- Implement proper caching strategies
- Optimize images and assets
- Use virtual scrolling for long lists
- Minimize bundle size
- Use proper preload strategies

## Testing
- Write unit tests for components and services
- Use TestBed for component testing
- Mock dependencies appropriately
- Test edge cases and error scenarios
- Maintain good test coverage
- Follow AAA pattern (Arrange, Act, Assert)

## Error Handling
- Implement proper error boundaries
- Use try-catch blocks appropriately
- Handle HTTP errors gracefully
- Show user-friendly error messages
- Log errors appropriately
- Implement global error handling

## State Management
- Use services for simple state management
- Consider signals for reactive state
- Implement proper caching strategies
- Handle loading states appropriately
- Manage form state effectively
- Keep state immutable

## Security
- Sanitize user input
- Use Angular's built-in XSS protection
- Implement proper authentication/authorization
- Follow OWASP security guidelines
- Use HTTPS for all API calls
- Implement CSRF protection

## Accessibility
- Use semantic HTML
- Implement ARIA labels
- Ensure keyboard navigation
- Test with screen readers
- Follow WCAG guidelines
- Provide alternative text for images

## Documentation
- Use JSDoc for documentation
- Document complex logic
- Keep README files updated
- Document API endpoints
- Include setup instructions
- Document build and deployment processes

## Version Control
- Use meaningful commit messages
- Follow conventional commits
- Create feature branches
- Review code before merging
- Keep dependencies updated
- Use proper versioning (SemVer)

## Routing
- Use standalone route configuration
- Implement lazy loading for routes
- Use route guards appropriately
- Handle route parameters properly
- Implement proper navigation
- Use route resolvers when needed

## Forms
- Use Reactive Forms when possible
- Implement proper validation
- Show validation errors appropriately
- Use typed forms
- Handle form state properly
- Implement proper form submission

## Data Management
- Use services for API calls
- Implement proper error handling
- Use proper typing for API responses
- Handle loading states
- Implement proper caching
- Use proper retry strategies

## Build & Deployment
- Use environment configurations
- Optimize production builds
- Implement proper CI/CD
- Use proper deployment strategies
- Monitor application performance
- Implement proper logging 